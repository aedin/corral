% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corral.R
\name{corral_mat}
\alias{corral_mat}
\alias{corral_sce}
\alias{corral}
\alias{print.corral}
\title{corral: Correspondence analysis on a single matrix}
\usage{
corral_mat(
  inp,
  method = c("irl", "svd"),
  ncomp = 30,
  row.w = NULL,
  col.w = NULL,
  ...
)

corral_sce(
  inp,
  method = c("irl", "svd"),
  ncomp = 30,
  whichmat = "counts",
  fullout = FALSE,
  subset_row = NULL,
  ...
)

corral(inp, ...)

\method{print}{corral}(x, ...)
}
\arguments{
\item{inp}{matrix (any type), \code{SingleCellExperiment}, or \code{SummarizedExperiment}. If using \code{SingleCellExperiment} or \code{SummarizedExperiment}, then include the \code{whichmat} argument to specify which slot to use (defaults to \code{counts}).}

\item{method}{character, the algorithm to be used for svd. Default is irl. Currently supports 'irl' for irlba::irlba or 'svd' for stats::svd}

\item{ncomp}{numeric, number of components; Default is 30}

\item{row.w}{numeric vector; the row weights to use in chi-squared scaling. Defaults to `NULL`, in which case row weights are computed from the input matrix.}

\item{col.w}{numeric vector; the column weights to use in chi-squared scaling. For instance, size factors could be given here. Defaults to `NULL`, in which case column weights are computed from the input matrix.}

\item{...}{(additional arguments for methods)}

\item{whichmat}{character; defaults to \code{counts}, can also use \code{logcounts} or \code{normcounts} if stored in the \code{sce} object}

\item{fullout}{boolean; whether the function will return the full \code{corral} output as a list, or a SingleCellExperiment; defaults to SingleCellExperiment (\code{FALSE}). To get back the \code{\link{corral_mat}}-style output, set this to \code{TRUE}.}

\item{subset_row}{numeric or character; vector of the rows to include in corral, either the indices (numeric) or the rownames (character). If this parameter is \code{NULL}, then all rows will be used.}

\item{x}{(print method) corral object; the list output from \code{corral_mat}}
}
\value{
When run on a matrix, a list with the correspondence analysis matrix decomposition result:
\describe{
    \item{\code{d}}{a vector of the diagonal singular values of the input \code{mat} (from SVD output)}
    \item{\code{u}}{a matrix of with the left singular vectors of \code{mat} in the columns (from SVD output)}
    \item{\code{v}}{a matrix of with the right singular vectors of \code{mat} in the columns. When cells are in the columns, these are the cell embeddings. (from SVD output)}
    \item{\code{eigsum}}{sum of the eigenvalues for calculating percent variance explained}
    \item{\code{SCu and SCv}}{standard coordinates, left and right, respectively}
    \item{\code{PCu and PCv}}{principal coordinates, left and right, respectively}
}

When run on a \code{\link{SingleCellExperiment}}, returns a SCE with the embeddings (PCv from the full corral output) in the \code{reducedDim} slot \code{corral} (default). Also can return the same output as \code{\link{corral_mat}} when \code{fullout} is set to \code{TRUE}.

For matrix and \code{SummarizedExperiment} input, returns list with the correspondence analysis matrix decomposition result (u,v,d are the raw svd output; SCu and SCv are the standard coordinates; PCu and PCv are the principal coordinates)

For \code{SummarizedExperiment} input, returns the same as for a matrix.

.
}
\description{
corral can be used for dimensionality reduction to find a set of low-dimensional embeddings for a count matrix.

\code{corral} is a wrapper for \code{\link{corral_mat}} and \code{\link{corral_sce}}, and can be called on any of the acceptable input types.
}
\examples{
mat <- matrix(sample(0:10, 5000, replace=TRUE), ncol=50)
result <- corral_mat(mat)
result <- corral_mat(mat, method = 'svd')
result <- corral_mat(mat, method = 'irl', ncomp = 5)

library(DuoClustering2018)
sce <- sce_full_Zhengmix4eq()[1:100,1:100]
result_1 <- corral_sce(sce)
result_2 <- corral_sce(sce, method = 'svd')
result_3 <- corral_sce(sce, method = 'irl', ncomp = 30, whichmat = 'logcounts')

# example on how to add UMAP based on corral above, with 'scater' package
library(scater)
result_1 <- runUMAP(result_1, dimred = 'corral', name = 'corral_UMAP')
result_1 <- runTSNE(result_1, dimred = 'corral', name = 'corral_TSNE')

library(DuoClustering2018)
sce <- sce_full_Zhengmix4eq()[1:100,1:100]
corral_sce <- corral(sce,whichmat = 'counts')

mat <- matrix(sample(0:10, 500, replace=TRUE), ncol=25)
corral_mat <- corral(mat, ncomp=5)

mat <- matrix(sample(1:100, 10000, replace = FALSE), ncol = 100)
corral(mat)
}
