% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corralm.R
\name{corralm_matlist}
\alias{corralm_matlist}
\alias{corralm_sce}
\alias{corralm}
\alias{print.corralm}
\title{Multi-table correspondence analysis (list of matrices)}
\usage{
corralm_matlist(matlist, method = c("irl", "svd")[1], ncomp = 10, ...)

corralm_sce(
  sce,
  splitby,
  method = c("irl", "svd")[1],
  ncomp = 10,
  whichmat = "counts",
  fullout = "false",
  ...
)

corralm(inp, ...)

\method{print}{corralm}(inp)
}
\arguments{
\item{matlist}{(for \code{corralm_matlist}) list of input matrices; input matrices should be counts (raw or log). Matrices should be aligned row-wise by common features (either by sample or by gene)}

\item{method}{character, the algorithm to be used for svd. Default is irl. Currently supports 'irl' for irlba::irlba or 'svd' for stats::svd}

\item{ncomp}{numeric, number of components; Default is 10}

\item{...}{(additional arguments for methods)}

\item{sce}{(for \code{corralm_sce}) SingleCellExperiment; containing the data to be integrated. Default is to use the counts, and to include all of the data in the integration. These can be changed by passing additional arguments. See \code{\link{sce2matlist}} function documentation for list of available parameters.}

\item{splitby}{character; name of the attribute from \code{colData} that should be used to separate the SCE}

\item{whichmat}{character; defaults to \code{counts}, can also use \code{logcounts} or \code{normcounts} if stored in the \code{sce} object}

\item{fullout}{boolean; whether the function will return the full \code{corral} output as a list, or a SingleCellExperiment; defaults to SingleCellExperiment (\code{FALSE}). To get back the \code{\link{corral_mat}}-style output, set this to \code{TRUE}.}

\item{inp}{corralm object; the list output from \code{corralm_matlist}}
}
\value{
When run on a list of matrices, a list with the correspondence analysis matrix decomposition result, with indices corresponding to the concatenated matrices (in order of the list):
\describe{
    \item{\code{d}}{a vector of the diagonal singular values of the input \code{mat} (from SVD output)}
    \item{\code{u}}{a matrix of with the left singular vectors of \code{mat} in the columns (from SVD output)}
    \item{\code{v}}{a matrix of with the right singular vectors of \code{mat} in the columns. When cells are in the columns, these are the cell embeddings. (from SVD output)}
    \item{\code{eigsum}}{sum of the eigenvalues for calculating percent variance explained}
}

For SingleCellExperiment input, returns the SCE with embeddings in the reducedDim slot 'corralm'

For a list of \code{\link{SingleCellExperiment}}s, returns a list of the SCEs with the embeddings in the respective \code{reducedDim} slot 'corralm'

.
}
\description{
This multi-table adaptation of correpondence analysis applies the same scaling technique and enables data alignment by finding a set of embeddings for each dataset within shared latent space.
}
\details{
\code{corralm} is a wrapper for \code{\link{corralm_matlist}} and \code{\link{corralm_sce}}, and can be called on any of the acceptable input types (see \code{inp} below).
}
\examples{
listofmats <- list(matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 25),
                   matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 25))
result <- corralm_matlist(listofmats)
library(DuoClustering2018)
library(SingleCellExperiment)
sce <- sce_full_Zhengmix4eq()[1:100,sample(1:3500,100,replace = FALSE)]
colData(sce)$Method <- matrix(sample(c('Method1','Method2'),100,replace = TRUE))
result <- corralm_sce(sce, splitby = 'Method')

#' # example on how to add UMAP/tsne based on corralm above, with 'scater' package
library(scater)
result <- runUMAP(result, dimred = 'corralm', name = 'corralm_UMAP')
result <- runTSNE(result, dimred = 'corralm', name = 'corralm_TSNE')

listofmats <- list(matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20),
                   matrix(sample(seq(0,20,1),1000,replace = TRUE),nrow = 20))
corralm(listofmats)

library(DuoClustering2018)
library(SingleCellExperiment)
sce <- sce_full_Zhengmix4eq()[1:100,sample(1:3500,100,replace = FALSE)]
colData(sce)$Method <- matrix(sample(c('Method1','Method2'),100,replace = TRUE))
result <- corralm(sce, splitby = 'Method')

}
